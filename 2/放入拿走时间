烧烤n串食物，给出n串食物的放入时间点s[i]和拿走时间点t[i]，但是拿走的时候，认不出哪个是第i个食物，会等概率随机选一个。然后问你最后每个食物没被烤熟预计考得太熟的概率分别是多少，就是在t[i]前拿走和t[i]后拿走的概率。所有的时间点s、t都不相同。以下是暴力代码，n^2的，不懂对不对，感觉挺靠谱的。再想想怎么优化。

#include<iostream>
#include<algorithm>
#include<vector>
#include<cstdio>
#include<set>
using namespace std;
const int N = 100005;
#define mp(x,y) make_pair(x,y)
typedef pair<int,int> per;
struct time_point
{
int t,flag,id;
}tp[N];
bool cmp(time_point x,time_point y)
{
return x.t<y.t;
}
struct fd
{
int s,t;
}food[N];
double und[N],sco[N],que_und[N],que_sco[N];
int enter_und[N],enter_sco[N],lev_und[N],lev_sco[N];
int main()
{
int n;
scanf("%d",&n);
int k=0;
for(int i=0;i<n;i++)
{
scanf("%d%d",&food[i].s,&food[i].t);
tp[k].t=food[i].s;
tp[k].flag=0;
tp[k].id=i;
k++;
tp[k].t=food[i].t;
tp[k].flag=1;
tp[k].id=i;
k++;
}
int p1=0,p2=0;
sort(tp,tp+k,cmp);
int cnt=0;
for(int i=0;i<k;i++)
{
if(tp[i].flag==0)
{
enter_und[tp[i].id]=p1;
cnt++;
}
else
{
lev_und[tp[i].id]=p1;
printf("p1:%d p2:%d cnt:%d i:%d \n",p1,p2,cnt,i);
que_und[p1++]=cnt;
que_sco[p2++]=cnt;
enter_sco[tp[i].id]=p2;
cnt--;
}
}
for(int i=0;i<n;i++)
{
printf("i:%d entund:%d levund:%d \n",i,enter_und[i],lev_und[i]);
und[i]=0.0;
for(int j=enter_und[i];j<lev_und[i];j++)
{
und[i]+=(1.0-und[i])*(1.0/que_und[j]);
}
}
for(int i=0;i<n;i++)
{
sco[i]=0.0;
double pre=und[i]+(1.0-und[i])*(1.0/que_und[lev_und[i]]);
for(int j=enter_sco[i];j<p2;j++)
{
printf("pre:%lf i:%d j:%d que_sco:%lf \n",pre,i,j,que_sco[j]);
sco[i]+=(1.0-pre)*(1.0/que_sco[j]);
pre+=(1.0-pre)*(1.0/que_sco[j]);
}
}
for(int i=0;i<n;i++)printf("%.9lf %.9lf\n",und[i],sco[i]);
return 0;
}